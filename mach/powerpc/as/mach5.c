static int hl_token;
static expr_t hl_expr;

void no_hl(void) {
    hl_token = 0;
}

word_t eval_hl(expr_t* expr, int token)
{
    word_t val = expr->val;
    uint16_t hi = val >> 16;
    uint16_t lo = val & 0xffff;

    hl_token = token;
    hl_expr = *expr;

    switch (token) {
    case OP_HI:
        /* hi16[expr] */
        return hi;
    case OP_HA:
        /* ha16[expr]: If the low half will be treated as a signed
         * value, then values greater than 0x7fff will cause the high
         * half to have 1 subtracted from it; so we apply an
         * adjustment here.
         */
        if (lo > 0x7fff)
            hi++;
        return hi;
    case OP_LO:
        /* lo16[expr] */
        return lo;
    }
}

void emit_hl(word_t in)
{
    int type;

    switch (hl_token) {
    case OP_HI:
    case OP_HA:
        type = hl_expr.typ & S_TYP;
        if (type != S_ABS)
            newrelo(hl_expr.typ, RELOPPC | FIXUPFLAGS);
	break;
    case OP_LO:
        /* If the assembler stored a symbol for relocation later, we
         * need to abandon it (because the relocation was generated by
         * hi16 or ha16). */
        type = hl_expr.typ & S_TYP;
        if (type != S_ABS)
            relonami = 0;
	break;
    }

    emit4(in);
}
