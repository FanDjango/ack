TYPES

    /* These are special and must always exist. */

    int;
    long;
    float;
    double;

    /* Any number of additional types can be defined, but they're of fairly limited use as values
     * of these types will never be spilt or copied. */

    cr;

REGISTERS

    /* Registers are allocated top down; the order here is odd in order to make
     * sure that non-volatile registers get allocated from r31 (or f31) down.
     *
     * Each register must be declared as having at least one type (listed above).
     * This allows the register to contain values of that type. They may also be
     * declared as having any number of additional attributes, which can be used
     * to constrain register selection.
     *
     * Register aliases may be defined with uses(reg1, reg2, ...). These work like
     * any other register, but they share hardware resources with some real registers.
     */

    r12                                        int volatile;
    r11                                        int volatile;
    r10                                        int volatile;
    r9                                         int volatile;
    r8                                         int volatile;
    r7                                         int volatile;
    r6                                         int volatile;
    r5                                         int volatile;
    r4                                         int volatile;
    r3                                         int volatile iret;

    r31                                        int;
    r30                                        int;
    r29                                        int;
    r28                                        int;
    r27                                        int;
    r26                                        int;
    r25                                        int;
    r24                                        int;
    r23                                        int;
    r22                                        int;
    r21                                        int;
    r20                                        int;
    r19                                        int;
    r18                                        int;
    r17                                        int;
    r16                                        int;
    r15                                        int;
    r14                                        int;
    r13                                        int;

    r11r12  named("r11", "r12") uses(r11, r12) long volatile;
    r9r10   named("r9",  "r10") uses(r9,  r10) long volatile;
    r7r8    named("r7",  "r8")  uses(r7,  r8)  long volatile;
    r5r6    named("r5",  "r6")  uses(r6,  r6)  long volatile;
    r3r4    named("r3",  "r4")  uses(r3,  r4)  long volatile lret;

    r29r30  named("r29", "r30") uses(r29, r30) long;
    r27r28  named("r27", "r28") uses(r27, r28) long;
    r25r26  named("r25", "r26") uses(r25, r26) long;
    r23r24  named("r23", "r24") uses(r23, r24) long;
    r21r22  named("r21", "r22") uses(r21, r22) long;
    r19r20  named("r19", "r20") uses(r19, r20) long;
    r17r18  named("r17", "r18") uses(r17, r18) long;
    r15r16  named("r15", "r16") uses(r15, r16) long;
    r13r14  named("r13", "r14") uses(r13, r14) long;

    f14                                        float double volatile;
    f13                                        float double volatile;
    f12                                        float double volatile;
    f11                                        float double volatile;
    f10                                        float double volatile;
    f9                                         float double volatile;
    f8                                         float double volatile;
    f7                                         float double volatile;
    f6                                         float double volatile;
    f5                                         float double volatile;
    f4                                         float double volatile;
    f3                                         float double volatile fret dret;
    f2                                         float double volatile;
    f1                                         float double volatile;
    f0                                         float double volatile;

    f31                                        float double;
    f30                                        float double;
    f29                                        float double;
    f28                                        float double;
    f27                                        float double;
    f26                                        float double;
    f25                                        float double;
    f24                                        float double;
    f23                                        float double;
    f22                                        float double;
    f21                                        float double;
    f20                                        float double;
    f19                                        float double;
    f18                                        float double;
    f17                                        float double;
    f16                                        float double;
    f15                                        float double;

	cr0                                        cr;



DECLARATIONS

	cr;
    ubyteX;   /* bottom 8 bits valid, the rest undefined */
    ubyte0;   /* bottom 8 bits valid, the rest 0 */
    ushortX;  /* bottom 16 bits valid, the rest undefined */
    ushort0;  /* bottom 16 bits valid, the rest 0 */

	address fragment;



PATTERNS

/* Special */

	PAIR(BLOCK.I, BLOCK.I);



/* Miscellaneous special things */

	PUSH.I(in:(int)reg)
		emit "stwu %in, -4(sp)"
		cost 4;

    PUSH.L(in:(long)reg)
        emit "stwu %in.0, -4(sp)"
        emit "stwu %in.1, -4(sp)"
        cost 8;

    PUSH.D(in:(double)reg)
        emit "stfdu %in, -8(sp)"
        cost 4;

	out:(int)reg = POP.I
		emit "lwz %out, 0(sp)"
        emit "addi sp, sp, 4"
		cost 8;

    out:(long)reg = POP.L
        emit "lwz %out.0, 4(sp)"
        emit "lwz %out.1, 0(sp)"
        emit "addi sp, sp, 8"
        cost 12;

	out:(float)reg = POP.F
		emit "lfs %out, 0(sp)"
		emit "addi sp, sp, 4"
		cost 8;

	out:(double)reg = POP.D
		emit "lfd %out, 0(sp)"
		emit "addi sp, sp, 8"
		cost 8;

	SETRET.I(in:(iret)reg)
		emit "! setret4"
		cost 1;

    SETRET.L(in:(lret)reg)
        emit "! setret8"
        cost 1;

	STACKADJUST.I(delta:CONST.I)
        when signed_constant(%delta, 16)
		emit "addi sp, sp, $delta"
		cost 4;

	STACKADJUST.I(in:(int)reg)
		emit "add sp, sp, %in"
		cost 4;

	STACKADJUST.I(NEG.I(in:(int)reg))
		emit "subf sp, %in, sp"
		cost 4;

    out:(int)reg = GETFP.I
        emit "mr %out, fp"
        cost 4;

    SETFP.I(in:(int)reg)
        emit "mr fp, %in"
        cost 4;

    out:(int)reg = CHAINFP.I(in:(int)reg)
        emit "lwz %out, 0(%in)"
        cost 4;

    out:(int)reg = FPTOAB.I(GETFP.I)
        emit "addi %out, fp, 8"
        cost 4;

    out:(int)reg = FPTOAB.I(in:(int)reg)
        emit "addi %out, %in, 8"
        cost 4;

    out:(int)reg = FPTOLB.I(in:(int)reg)
        with %out == %in
        cost 1;

    out:(int)reg = GETSP.I
        emit "mr %out, sp"
        cost 4;

    SETSP.I(in:(int)reg)
        emit "mr sp, %in"
        cost 4;

    out:(int)reg = ANY.I
        cost 1;

    out:(int)reg = COPYF.I(in:(float)reg)
        emit "stfsu %in, -4(sp)"
        emit "lwz %out, 0(sp)"
        emit "addi sp, sp, 4"
        cost 12;

    out:(double)reg = COPYL.D(in:(long)reg)
        emit "stwu %in.0, -4(sp)"
        emit "stwu %in.1, -4(sp)"
        emit "lfd %out, 0(sp)"
        emit "addi sp, sp, 8"
        cost 16;

    out:(long)reg = COPYD.L(in:(double)reg)
        emit "stfdu %in, -8(sp)"
        emit "lwz %out.0, 4(sp)"
        emit "lwz %out.1, 0(sp)"
        emit "addi sp, sp, 8"
        cost 16;



/* Memory operations */

    /* Stores */

	STORE.D(addr:address, value:(double)reg)
        emit "stfd %value, %addr"
		cost 4;

	STORE.L(addr:address, value:(long)reg)
		emit "stw %value.0, 4+%addr"
		emit "stw %value.1, 0+%addr"
		cost 8;

	STORE.I(addr:address, value:(int)reg)
		emit "stw %value, %addr"
		cost 4;

	STOREH.I(addr:address, value:(int)ushortX)
		emit "sth %value, %addr"
		cost 4;

    STOREH.I(ADD.I(left:(int)reg, right:(int)reg), value:(int)ushortX)
        emit "sthx %value, %left, %right"
        cost 4;

	STOREB.I(addr:address, value:(int)ushortX)
		emit "sth %value, %addr"
		cost 4;

    STOREB.I(addr:address, value:(int)ubyteX)
		emit "stb %value, %addr"
		cost 4;

    STOREB.I(ADD.I(left:(int)reg, right:(int)reg), value:(int)ubyteX)
        emit "stbx %value, %left, %right"
        cost 4;

    /* Loads */

	out:(int)reg = LOAD.I(addr:address)
		emit "lwz %out, %addr"
		cost 4;

    out:(long)reg = LOAD.L(addr:address)
        with corrupted(%addr)
        emit "lwz %out.0, 4+%addr"
        emit "lwz %out.1, 0+%addr"
        cost 8;

	out:(int)ushort0 = LOADH.I(addr:address)
		emit "lhz %out, %addr"
		cost 4;

	out:(int)ubyte0 = LOADB.I(addr:address)
		emit "lbz %out, %addr"
		cost 4;

    /* ubyte intrinsics */

    out:(int)ubyteX = in:(int)ubyte0
        with %out == %in
        emit "! ubyte0 -> ubyteX"
        cost 1;

    out:(int)ubyte0 = in:(int)ubyteX
        emit "andi %out, %in, 0xff ! ubyteX -> ubyte0"
        cost 4;

    out:(int)reg = in:(int)ubyte0
        with %out == %in
        emit "! ubyte0 -> reg"
        cost 4;

    out:(int)ubyteX = in:(int)reg
        with %out == %in
        emit "! reg -> ubyteX"
        cost 1;

    /* ushort intrinsics */

    out:(int)ushortX = in:(int)ushort0
        with %out == %in
        emit "! ushort0 -> ushortX"
        cost 1;

    out:(int)ushort0 = in:(int)ushortX
        emit "andi %out, %in, 0xff ! ushortX -> ushort0"
        cost 4;

    out:(int)reg = in:(int)ushort0
        with %out == %in
        emit "! ushort0 -> reg"
        cost 4;

    out:(int)ushortX = in:(int)reg
        with %out == %in
        emit "! reg -> ushortX"
        cost 1;


/* Extensions and conversions */

    out:(int)reg = EXTENDB.I(in:(int)reg)
        emit "extsb %out, %in"
        cost 4;

    out:(int)reg = EXTENDH.I(in:(int)reg)
        emit "extsh %out, %in"
        cost 4;

    out:(int)reg = FROMSI.I(in:(int)reg)
        with %out == %in
        emit "! FROMSI.I(int) -> int"
        cost 1;

    out:(int)reg = FROMUI.I(in:(int)reg)
        with %out == %in
        emit "! FROMUI.I(int) -> int"
        cost 1;

    out:(long)reg = FROMSI.L(in:(int)reg)
        emit "mr %out.0, %in"
        emit "srawi %out.1, %out.0, 31"
        cost 8;

    out:(long)reg = FROMUI.L(in:(int)reg)
        emit "mr %out.0, %in"
        emit "li32 %out.1, 0"
        cost 8;

    out:(iret)reg = FROMSF.I(in:(dret)reg)
        with corrupted(volatile)
        emit "bl .fromf2i"
        cost 4;

    out:(int)reg = FROMSD.I(in:(double)reg)
        with corrupted(%in)
        emit "fctiwz %in, %in"
        emit "stfdu %in, -8(sp)"
        emit "lwz %out, 4(sp)"
        emit "addi sp, sp, 8"
        cost 16;

    out:(int)reg = FROMUD.I(in:(double)reg)
        with corrupted(volatile)
        emit "stfdu %in, -8(sp)"
        emit "bl .cfu8"
        emit "lwz %out, 0(sp)"
        emit "addi sp, sp, 4"
        cost 16;

    out:(lret)reg = FROMSF.L(in:(fret)reg)
        with corrupted(volatile)
        emit "bl .fromf2l"
        cost 4;

    out:(lret)reg = FROMUF.I(in:(fret)reg)
        with corrupted(volatile)
        emit "bl .fromf2l"
        cost 4;

    out:(double)reg = FROMSI.D(in:(int)reg)
        with corrupted(volatile)
        emit "stwu %in, -4(sp)"
        emit "bl .cif8"
        emit "lfd %out, 0(sp)"
        emit "addi sp, sp, 8"
        cost 4;

    out:(fret)reg = FROMUI.F(in:(iret)reg)
        with corrupted(volatile)
        emit "bl .fromui2f"
        cost 4;

    out:(double)reg = FROMUI.D(in:(int)reg)
        with corrupted(volatile)
        emit "stwu %in, -4(sp)"
        emit "bl .cuf8"
        emit "lfd %out, 0(sp)"
        emit "addi sp, sp, 8"
        cost 4;

    out:(lret)reg = FROMIPAIR.L(in1:(int)reg, in2:(int)reg)
        emit "mr %out.0, %in1"
        emit "mr %out.1, %in2"
        cost 8;

    out:(int)reg = FROML0.I(in:(long)reg)
        emit "mr %out, %in.0"
        cost 4;

    out:(int)reg = FROML1.I(in:(long)reg)
        emit "mr %out, %in.1"
        cost 4;



/* Locals */

	out:(int)reg = in:LOCAL.I
		emit "addi %out, fp, $in"
		cost 4;

	address = in:LOCAL.I
		emit "$in(fp)";




/* Memory addressing modes */

	address = ADD.I(addr:(int)reg, offset:CONST.I)
        when signed_constant(%offset, 16)
		emit "$offset(%addr)";

	address = addr:(int)reg
		emit "0(%addr)";



/* Branches */

	JUMP(addr:BLOCK.I)
		emit "b $addr"
		cost 4;

	FARJUMP(addr:LABEL.I)
        with corrupted(volatile)
		emit "b $addr"
		cost 4;

    JUMP(dest:(int)reg)
        emit "mtspr ctr, %dest"
        emit "bcctrl 20, 0, 0"
        cost 8;

	CJUMPEQ(value:(cr)cr, PAIR(true:BLOCK.I, false:BLOCK.I))
        emit "bc 12, 2, $true" /* IFTRUE EQ */
		emit "b $false"
		cost 8;

	CJUMPLE(value:(cr)cr, PAIR(true:BLOCK.I, false:BLOCK.I))
        emit "bc 4, 1, $true" /* IFFALSE GT */
        emit "b $false"
		cost 8;

	CJUMPLT(value:(cr)cr, PAIR(true:BLOCK.I, false:BLOCK.I))
        emit "bc 12, 0, $true" /* IFTRUE LT */
        emit "b $false"
		cost 8;

    #define CALLLABEL(insn) \
        insn (dest:LABEL.I) \
            with corrupted(volatile) \
            emit "bl $dest" \
            cost 4;

    CALLLABEL(CALL)
    out:(iret)reg = CALLLABEL(CALL.I)
    out:(fret)reg = CALLLABEL(CALL.F)
    out:(lret)reg = CALLLABEL(CALL.L)
    out:(dret)reg = CALLLABEL(CALL.D)

    #define CALLINDIRECT(insn) \
        insn (dest:(int)reg) \
            with corrupted(volatile) \
            emit "mtspr ctr, %dest" \
            emit "bcctrl 20, 0, 0" \
            cost 8;

    CALLINDIRECT(CALL)
    out:(iret)reg = CALLINDIRECT(CALL.I)
    out:(fret)reg = CALLINDIRECT(CALL.F)
    out:(lret)reg = CALLINDIRECT(CALL.L)
    out:(dret)reg = CALLINDIRECT(CALL.D)

    JUMP(dest:LABEL.I)
        emit "b $dest"
        cost 4;



/* Comparisons */

	cr:(cr)cr = COMPARESI.I(left:(int)reg, right:(int)reg)
        emit "cmp %cr, 0, %left, %right"
		cost 4;

	cr:(cr)cr = COMPARESI.I(left:(int)reg, right:CONST.I)
        when signed_constant(%right, 16)
        emit "cmpi %cr, 0, %left, $right"
		cost 4;

	cr:(cr)cr = COMPAREUI.I(left:(int)reg, right:(int)reg)
        emit "cmpl %cr, 0, %left, %right"
		cost 4;

	cr:(cr)cr = COMPAREUI.I(left:(int)reg, right:CONST.I)
        when signed_constant(%right, 16)
        emit "cmpli %cr, 0, %left, $right"
		cost 4;

    out:(cr)cr = COMPARESI.I(in:(cr)cr, result:CONST.I)
        when specific_constant(%result, 0)
        with %out == %in
        emit "! COMPARESI.I(cr, 0)"
        cost 4;



/* Booleans */

    out:(int)reg = IFEQ.I(in:(cr)cr)
        emit "mfcr %out" /* get cr0 */
        emit "rlwinm %out, %out, 3, 31, 31"      /* extract just EQ */
        cost 8;

#if 0
    out:(int)reg = IFEQ.I(in:(int)reg)
        emit "cntlzw %out, %in" /* returns 0..32 */
        emit "rlwinm %out, %out, [32-5], 31, 31" /* if 32, return 1, otherwise 0 */
        cost 8;
#endif

    out:(int)reg = IFLT.I(in:(cr)cr)
        emit "mfcr %out" /* get cr0 */
        emit "rlwinm %out, %out, 1, 31, 31"     /* leave just LT */
        cost 8;

    out:(int)reg = IFLE.I(in:(cr)cr)
        emit "mfcr %out"                        /* get cr0 */
        emit "rlwinm %out, %out, 2, 31, 31"     /* leave just GT */
        emit "xori %out, %out, 1"               /* negate */
        cost 12;



/* Conversions */

#if 0
    out:(int)reg = CIU44(in:(int)reg)
        with %out == %in
        emit "! ciu44"
        cost 4;

    out:(int)reg = CUI44(in:(int)reg)
        with %out == %in
        emit "! cui44"
        cost 4;
#endif

/* ALU operations */

    #define ALUR(name, instr) \
        out:(int)reg = name(left:(int)reg, right:(int)reg) \
            emit instr " %out, %left, %right"              \
            cost 4;                                        \

    #define ALUC(name, instr) \
        out:(int)reg = name(left:(int)reg, right:CONST.I)  \
            when signed_constant(%right, 16)               \
            emit instr " %out, %left, $right"              \
            cost 4;                                        \

    #define ALUC_reversed(name, instr) \
        out:(int)reg = name(left:CONST.I, right:(int)reg)  \
            when signed_constant(%left, 16)                \
            emit instr " %out, %right, $left"              \
            cost 4;                                        \

    #define ALUCC(name, instr) \
        ALUC(name, instr) \
        ALUC_reversed(name, instr)

    ALUR(ADD.I, "add")
    ALUCC(ADD.I, "addi")

	out:(int)reg = SUB.I(left:(int)reg, right:(int)reg)
		emit "subf %out, %right, %left"
		cost 4;

	out:(int)reg = SUB.I(left:(int)reg, right:CONST.I)
		emit "addi %out, %left, -[$right]"
		cost 4;

	out:(int)reg = MOD.I(left:(int)reg, right:(int)reg)
        with corrupted(%left), corrupted(%right)
		emit "divw %out, %left, %right"
        emit "mullw %out, %out, %right"
        emit "subf %out, %out, %left"
		cost 12;

	out:(int)reg = MODU.I(left:(int)reg, right:(int)reg)
        with corrupted(%left), corrupted(%right)
		emit "divwu %out, %left, %right"
        emit "mullw %out, %out, %right"
        emit "subf %out, %out, %left"
		cost 12;

    ALUR(MUL.I, "mullw")
    ALUCC(MUL.I, "mulli")

    ALUR(DIV.I, "divw")
    ALUR(DIVU.I, "divwu")

    ALUR(ASL.I, "slw")
    ALUR(ASR.I, "sraw")

    ALUR(LSL.I, "slw")
    ALUR(LSR.I, "srw")

    out:(int)reg = NEG.I(left:(int)reg)
        emit "neg %out, %left"
        cost 4;

    out:(int)reg = NOT.I(in:(int)reg)
        emit "nor %out, %in, %in"
        cost 4;

    ALUR(AND.I, "and")
    ALUCC(AND.I, "andi.")

    ALUR(OR.I, "or")
    ALUCC(OR.I, "ori")

    ALUR(EOR.I, "xor")
    ALUCC(EOR.I, "xori")

	out:(int)reg = value:LABEL.I
		emit "li32 %out, $value"
		cost 4;

	out:(int)reg = value:BLOCK.I
		emit "li32 %out, $value"
		cost 4;

	out:(int)reg = value:CONST.I
		emit "li32 %out, $value"
		cost 8;


/* FPU operations */

    #define FPU4R(name, instr) \
        out:(float)reg = name(left:(float)reg, right:(float)reg) \
            emit instr " %out, %left, %right"                    \
            cost 4;                                              \

    #define FPU8R(name, instr) \
        out:(double)reg = name(left:(double)reg, right:(double)reg) \
            emit instr " %out, %left, %right"                       \
            cost 4;                                                 \

    out:(float)reg = LOAD.F(addr:address)
        emit "lfs %out, %addr"
        cost 4;

    out:(double)reg = LOAD.D(addr:address)
        emit "lfd %out, %addr"
        cost 4;

    out:(float)reg = in:CONST.F
        when specific_constant(%in, 0)
        emit "li32 r0, .fd_00000000"
        emit "lfs %out, 0(r0)"
        cost 12;

    FPU4R(ADDF.F, "fadds")
    FPU8R(ADDF.D, "fadd")

    FPU4R(SUBF.F, "fsubs")
    FPU8R(SUBF.D, "fsub")

    FPU4R(MULF.F, "fmuls")
    FPU8R(MULF.D, "fmul")

    FPU4R(DIVF.F, "fdivs")
    FPU8R(DIVF.D, "fdiv")

    #define FMALEFT(type, insn, add, mul) \
        out:(type)reg = add(mul(m1:(type)reg, m2:(type)reg), m3:(type)reg) \
        emit insn " %out, %m1, %m2, %m3"                                   \
        cost 4;                                                            \

    #define FMARIGHT(type, insn, add, mul) \
        out:(type)reg = add(m3:(type)reg, mul(m1:(type)reg, m2:(type)reg)) \
        emit insn " %out, %m1, %m2, %m3"                                   \
        cost 4;                                                            \

    FMALEFT( double, "fmadd",   ADDF.D, MULF.D)
    FMARIGHT(double, "fmadd",   ADDF.D, MULF.D)
    FMALEFT( float,  "fmadds",  ADDF.F, MULF.F)
    FMARIGHT(float,  "fmadds",  ADDF.F, MULF.F)

    FMALEFT( double, "fmsub",   SUBF.D, MULF.D)
    FMALEFT( float,  "fmsubs",  SUBF.F, MULF.F)

    FMARIGHT(double, "fnmadd",  SUBF.D, MULF.D)
    FMARIGHT(float,  "fnmadds", SUBF.F, MULF.F)

    #define FMANEGLEFT(type, insn, neg, add, mul) \
        out:(type)reg = neg(add(mul(m1:(type)reg, m2:(type)reg), m3:(type)reg)) \
        emit insn " %out, %m1, %m2, %m3"                                        \
        cost 4;                                                                 \

    #define FMANEGRIGHT(type, insn, neg, add, mul) \
        out:(type)reg = neg(add(m3:(type)reg, mul(m1:(type)reg, m2:(type)reg))) \
        emit insn " %out, %m1, %m2, %m3"                                        \
        cost 4;                                                                 \

    FMANEGLEFT( double, "fnmsub", NEGF.D, ADDF.D, MULF.D)
    FMANEGRIGHT(double, "fnmsub", NEGF.D, ADDF.D, MULF.D)
    FMANEGLEFT( float,  "fnmsub", NEGF.F, ADDF.F, MULF.F)
    FMANEGRIGHT(float,  "fnmsub", NEGF.F, ADDF.F, MULF.F)

    out:(float)reg = NEGF.F(left:(float)reg)
        emit "fneg %out, %left"
        cost 4;

    out:(double)reg = NEGF.D(left:(double)reg)
        emit "fneg %out, %left"
        cost 4;

	cr:(cr)cr = COMPAREF.I(left:(float)reg, right:(float)reg)
        emit "fcmpu %cr, %left, %right"
		cost 4;

	cr:(cr)cr = COMPARED.I(left:(double)reg, right:(double)reg)
        emit "fcmpu %cr, %left, %right"
		cost 4;

/* vim: set sw=4 ts=4 expandtab : */

